"use strict";
var fs = require('fs');
// import process = require('process')
var path = require('path');
var file_utils_1 = require('../lib/file-utils');
var temp = require('temp');
var loglevel = require('loglevel');
var Promise = require('bluebird');
var child_process_1 = require('child_process');
var index_1 = require('../lib/index');
var log = loglevel.getLogger('full-stack-smoke');
describe("full-stack-smoke", function () {
    var projectPath = undefined;
    var originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 200000;
    var client = undefined;
    beforeAll(function (done) {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = 200000;
        temp.track();
        originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
        projectPath = temp.mkdirSync('ensime-integration-test');
        generateProject(projectPath).then(function () {
            fs.exists(path.join(projectPath, "build.sbt"), function (buildDotSbtExists) {
                expect(buildDotSbtExists);
                genDotEnsime(projectPath).then(function (exitCode) {
                    expect(exitCode).toBe(0);
                    var dotEnsimePath = path.join(projectPath, ".ensime");
                    fs.exists(dotEnsimePath, function (dotEnsimeExists) {
                        expect(dotEnsimeExists);
                    });
                    startEnsime(dotEnsimePath).then(function (c) {
                        log.debug('got a connected client', c);
                        client = c;
                        done();
                    });
                });
            });
        });
    });
    afterAll(function (done) {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;
        client.destroy();
        temp.cleanupSync();
        fs.exists(projectPath, function (exists) {
            expect(exists).toBeFalsy();
            done();
        });
    });
    /**
     * Generates project structure and build.sbt
     */
    var generateProject = function (dir) {
        fs.mkdirSync(path.join(dir, 'src'));
        fs.mkdirSync(path.join(dir, 'project'));
        fs.mkdirSync(path.join(dir, 'src', 'main'));
        fs.mkdirSync(path.join(dir, 'src', 'main', 'scala'));
        var buildDotSbt = "\n            lazy val commonSettings = Seq(\n                organization := \"org.ensime\",\n                version := \"0.1-SNAPSHOT\",\n                scalaVersion := \"2.11.8\"\n            )\n\n            lazy val root = (project in file(\".\")).\n                settings(commonSettings: _*).\n                settings(\n                    name := \"ensime-test-project\"\n                )\n        ";
        // http://stackoverflow.com/questions/37833355/how-to-specify-which-overloaded-function-i-want-in-typescript/37835265#37835265
        var buildSbtP = file_utils_1.writeFile(path.join(dir, "build.sbt"), buildDotSbt);
        var pluginsSbtP = file_utils_1.writeFile(path.join(dir, 'project', 'plugins.sbt'), "addSbtPlugin(\"org.ensime\" % \"sbt-ensime\" % \"0.6.0\")");
        return Promise.all([buildDotSbt, pluginsSbtP]);
    };
    /**
     * Calls sbt ensimeConfig to generate .ensime
     */
    var genDotEnsime = function (dir) {
        var pid = child_process_1.spawn("sbt", ["ensimeConfig"], { cwd: dir });
        var p = Promise.defer();
        pid.stdin.end();
        pid.stdout.on('data', function (chunk) {
            log.info('ensimeConfig', chunk.toString('utf8'));
        });
        pid.on('close', function (exitCode) {
            p.resolve(exitCode);
        });
        return p.promise;
    };
    function startEnsime(dotEnsimePath) {
        return index_1.dotEnsimeUtils.parseDotEnsime(dotEnsimePath).then(function (dotEnsime) {
            log.debug("got a parsed .ensime");
            var serverStarter = function (project) {
                var assemblyJar = process.env.ENSIME_ASSEMBLY_JAR;
                if (!assemblyJar) {
                    log.error("Please point to assembly jar with env ENSIME_ASSEMBLY_JAR");
                    fail("Please point to assembly jar with env ENSIME_ASSEMBLY_JAR");
                }
                return index_1.startServerFromAssemblyJar(assemblyJar, project);
            };
            return index_1.clientStarterFromServerStarter(serverStarter)(dotEnsime, "2.0.0-SNAPSHOT", function (msg) {
                log.debug(msg);
            });
        });
    }
    it("should get connection info", function (done) {
        var fooDotScala = path.join(projectPath, "src", "main", "scala", "Foo.scala");
        var content = "\n            object Foo {\n                def bar = \"baz\";\n            }\n        ";
        file_utils_1.writeFile(fooDotScala, content);
        client.post({ "typehint": "ConnectionInfoReq" }).then(function (res) {
            log.debug("got an answer: ", res);
            // client.typecheckFile(fooDotScala);
            // client.typecheckBuffer(fooDotScala, content, (res) => {
            //     log.debug("got an answer: ", res)
            // });
            done();
        });
    });
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNwZWMtaW50ZWdyYXRpb24vZnVsbC1zdGFjay1zbW9rZS10ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxJQUFPLEVBQUUsV0FBVyxJQUFJLENBQUMsQ0FBQTtBQUN6QixzQ0FBc0M7QUFFdEMsSUFBWSxJQUFJLFdBQU0sTUFBTSxDQUFDLENBQUE7QUFDN0IsMkJBQWtDLG1CQUFtQixDQUFDLENBQUE7QUFFdEQsSUFBTyxJQUFJLFdBQVcsTUFBTSxDQUFDLENBQUM7QUFFOUIsSUFBTyxRQUFRLFdBQVcsVUFBVSxDQUFDLENBQUM7QUFDdEMsSUFBTyxPQUFPLFdBQVcsVUFBVSxDQUFDLENBQUM7QUFDckMsOEJBQW9CLGVBQWUsQ0FBQyxDQUFBO0FBQ3BDLHNCQUF3SCxjQUN4SCxDQUFDLENBRHFJO0FBR3RJLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUVuRCxRQUFRLENBQUMsa0JBQWtCLEVBQUU7SUFDekIsSUFBSSxXQUFXLEdBQVksU0FBUyxDQUFDO0lBRXJDLElBQUksZUFBZSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQztJQUN2RCxPQUFPLENBQUMsd0JBQXdCLEdBQUcsTUFBTSxDQUFBO0lBQ3pDLElBQUksTUFBTSxHQUFzQixTQUFTLENBQUE7SUFFekMsU0FBUyxDQUFDLFVBQUMsSUFBSTtRQUNYLE9BQU8sQ0FBQyx3QkFBd0IsR0FBRyxNQUFNLENBQUE7UUFDekMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsZUFBZSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQTtRQUNsRCxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBQ3hELGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDOUIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsRUFBRSxV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Qyw0QkFBNEIsRUFBRSxVQUFDLElBQUk7UUFDbEMsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUE7UUFDL0UsSUFBTSxPQUFPLEdBQUcseUZBSWYsQ0FBQztRQUNGLHNCQUFTLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2hDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBQyxVQUFVLEVBQUMsbUJBQW1CLEVBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLEdBQUc7WUFDbkQsR0FBRyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLENBQUMsQ0FBQTtZQUNqQyxxQ0FBcUM7WUFDckMsMERBQTBEO1lBQzFELHdDQUF3QztZQUN4QyxNQUFNO1lBQ04sSUFBSSxFQUFFLENBQUM7UUFDWCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJmaWxlIjoic3BlYy1pbnRlZ3JhdGlvbi9mdWxsLXN0YWNrLXNtb2tlLXRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgPSByZXF1aXJlKCdmcycpXG4vLyBpbXBvcnQgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MnKVxuXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHt3cml0ZUZpbGUsIHJlYWRGaWxlfSBmcm9tICcuLi9saWIvZmlsZS11dGlscyc7XG5cbmltcG9ydCB0ZW1wID0gcmVxdWlyZSgndGVtcCcpO1xuXG5pbXBvcnQgbG9nbGV2ZWwgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xuaW1wb3J0IFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuaW1wb3J0IHtzcGF3bn0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQge0RvdEVuc2ltZSwgU2VydmVyU3RhcnRlciwgcGlkLCBjbGllbnRTdGFydGVyRnJvbVNlcnZlclN0YXJ0ZXIsIHN0YXJ0U2VydmVyRnJvbUFzc2VtYmx5SmFyLCBkb3RFbnNpbWVVdGlsc30gZnJvbSAnLi4vbGliL2luZGV4J1xuaW1wb3J0IHtTZXJ2ZXJDb25uZWN0aW9ufSBmcm9tICcuLi9saWIvc2VydmVyLWFwaS9zZXJ2ZXItY29ubmVjdGlvbidcblxuY29uc3QgbG9nID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKCdmdWxsLXN0YWNrLXNtb2tlJyk7XG5cbmRlc2NyaWJlKFwiZnVsbC1zdGFjay1zbW9rZVwiLCAoKSA9PiB7XG4gICAgbGV0IHByb2plY3RQYXRoOiBzdHJpbmcgID0gdW5kZWZpbmVkO1xuICAgIFxuICAgIGxldCBvcmlnaW5hbFRpbWVvdXQgPSBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDsgICBcbiAgICBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IDIwMDAwMFxuICAgIGxldCBjbGllbnQgOiBTZXJ2ZXJDb25uZWN0aW9uID0gdW5kZWZpbmVkXG5cbiAgICBiZWZvcmVBbGwoKGRvbmUpID0+IHtcbiAgICAgICAgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwgPSAyMDAwMDBcbiAgICAgICAgdGVtcC50cmFjaygpO1xuICAgICAgICBvcmlnaW5hbFRpbWVvdXQgPSBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTFxuICAgICAgICBwcm9qZWN0UGF0aCA9IHRlbXAubWtkaXJTeW5jKCdlbnNpbWUtaW50ZWdyYXRpb24tdGVzdCcpO1xuICAgICAgICBnZW5lcmF0ZVByb2plY3QocHJvamVjdFBhdGgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZnMuZXhpc3RzKHBhdGguam9pbihwcm9qZWN0UGF0aCwgXCJidWlsZC5zYnRcIiksIChidWlsZERvdFNidEV4aXN0cykgPT4ge1xuICAgICAgICAgICAgICAgIGV4cGVjdChidWlsZERvdFNidEV4aXN0cyk7XG4gICAgICAgICAgICAgICAgZ2VuRG90RW5zaW1lKHByb2plY3RQYXRoKS50aGVuKChleGl0Q29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoZXhpdENvZGUpLnRvQmUoMCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3RFbnNpbWVQYXRoID0gcGF0aC5qb2luKHByb2plY3RQYXRoLCBcIi5lbnNpbWVcIik7IFxuICAgICAgICAgICAgICAgICAgICBmcy5leGlzdHMoZG90RW5zaW1lUGF0aCwgKGRvdEVuc2ltZUV4aXN0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGRvdEVuc2ltZUV4aXN0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFbnNpbWUoZG90RW5zaW1lUGF0aCkudGhlbigoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdnb3QgYSBjb25uZWN0ZWQgY2xpZW50JywgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTsgXG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgXG4gICAgfSk7XG5cbiAgICBhZnRlckFsbCgoZG9uZSkgPT4ge1xuICAgICAgICBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IG9yaWdpbmFsVGltZW91dDtcbiAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgICAgdGVtcC5jbGVhbnVwU3luYygpO1xuICAgICAgICBmcy5leGlzdHMocHJvamVjdFBhdGgsIChleGlzdHMpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChleGlzdHMpLnRvQmVGYWxzeSgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBwcm9qZWN0IHN0cnVjdHVyZSBhbmQgYnVpbGQuc2J0XG4gICAgICovICAgIFxuICAgIGNvbnN0IGdlbmVyYXRlUHJvamVjdCA9IChkaXI6IHN0cmluZykgPT4ge1xuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5qb2luKGRpciwgJ3NyYycpKTtcbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguam9pbihkaXIsICdwcm9qZWN0JykpO1xuXG4gICAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmpvaW4oZGlyLCAnc3JjJywgJ21haW4nKSk7XG4gICAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmpvaW4oZGlyLCAnc3JjJywgJ21haW4nLCAnc2NhbGEnKSk7XG5cbiAgICAgICAgY29uc3QgYnVpbGREb3RTYnQgPSBgXG4gICAgICAgICAgICBsYXp5IHZhbCBjb21tb25TZXR0aW5ncyA9IFNlcShcbiAgICAgICAgICAgICAgICBvcmdhbml6YXRpb24gOj0gXCJvcmcuZW5zaW1lXCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbiA6PSBcIjAuMS1TTkFQU0hPVFwiLFxuICAgICAgICAgICAgICAgIHNjYWxhVmVyc2lvbiA6PSBcIjIuMTEuOFwiXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGxhenkgdmFsIHJvb3QgPSAocHJvamVjdCBpbiBmaWxlKFwiLlwiKSkuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MoY29tbW9uU2V0dGluZ3M6IF8qKS5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA6PSBcImVuc2ltZS10ZXN0LXByb2plY3RcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgYDtcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3ODMzMzU1L2hvdy10by1zcGVjaWZ5LXdoaWNoLW92ZXJsb2FkZWQtZnVuY3Rpb24taS13YW50LWluLXR5cGVzY3JpcHQvMzc4MzUyNjUjMzc4MzUyNjVcblxuICAgICAgICBjb25zdCBidWlsZFNidFAgPSB3cml0ZUZpbGUocGF0aC5qb2luKGRpciwgXCJidWlsZC5zYnRcIiksIGJ1aWxkRG90U2J0KTsgICAgXG5cbiAgICAgICAgY29uc3QgcGx1Z2luc1NidFAgPSB3cml0ZUZpbGUocGF0aC5qb2luKGRpciwgJ3Byb2plY3QnLCAncGx1Z2lucy5zYnQnKSxcbiAgICAgICAgIGBhZGRTYnRQbHVnaW4oXCJvcmcuZW5zaW1lXCIgJSBcInNidC1lbnNpbWVcIiAlIFwiMC42LjBcIilgKVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbYnVpbGREb3RTYnQsIHBsdWdpbnNTYnRQXSlcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgc2J0IGVuc2ltZUNvbmZpZyB0byBnZW5lcmF0ZSAuZW5zaW1lXG4gICAgICovXG4gICAgY29uc3QgZ2VuRG90RW5zaW1lID0gKGRpcjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBpZCA9IHNwYXduKFwic2J0XCIsIFtcImVuc2ltZUNvbmZpZ1wiXSwge2N3ZDogZGlyfSk7XG4gICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLmRlZmVyPG51bWJlcj4oKTtcblxuICAgICAgICBwaWQuc3RkaW4uZW5kKCk7XG4gICAgICAgIFxuICAgICAgICBwaWQuc3Rkb3V0Lm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICBsb2cuaW5mbygnZW5zaW1lQ29uZmlnJywgY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICAgICAgfSlcblxuICAgICAgICBwaWQub24oJ2Nsb3NlJywgKGV4aXRDb2RlOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgcC5yZXNvbHZlKGV4aXRDb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwLnByb21pc2U7IFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzdGFydEVuc2ltZShkb3RFbnNpbWVQYXRoOiBzdHJpbmcpOiBQcm9taXNlTGlrZTxTZXJ2ZXJDb25uZWN0aW9uPiB7XG4gICAgICAgIHJldHVybiBkb3RFbnNpbWVVdGlscy5wYXJzZURvdEVuc2ltZShkb3RFbnNpbWVQYXRoKS50aGVuKChkb3RFbnNpbWUpID0+IHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcImdvdCBhIHBhcnNlZCAuZW5zaW1lXCIpXG4gICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3Qgc2VydmVyU3RhcnRlciA6IFNlcnZlclN0YXJ0ZXIgPSAocHJvamVjdDogRG90RW5zaW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZW1ibHlKYXIgPSBwcm9jZXNzLmVudi5FTlNJTUVfQVNTRU1CTFlfSkFSO1xuICAgICAgICAgICAgICAgIGlmKCEgYXNzZW1ibHlKYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiUGxlYXNlIHBvaW50IHRvIGFzc2VtYmx5IGphciB3aXRoIGVudiBFTlNJTUVfQVNTRU1CTFlfSkFSXCIpXG4gICAgICAgICAgICAgICAgICAgIGZhaWwoXCJQbGVhc2UgcG9pbnQgdG8gYXNzZW1ibHkgamFyIHdpdGggZW52IEVOU0lNRV9BU1NFTUJMWV9KQVJcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VydmVyRnJvbUFzc2VtYmx5SmFyKGFzc2VtYmx5SmFyLCBwcm9qZWN0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50U3RhcnRlckZyb21TZXJ2ZXJTdGFydGVyKHNlcnZlclN0YXJ0ZXIpKGRvdEVuc2ltZSwgXCIyLjAuMC1TTkFQU0hPVFwiLCAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKG1zZyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgaXQoXCJzaG91bGQgZ2V0IGNvbm5lY3Rpb24gaW5mb1wiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBmb29Eb3RTY2FsYSA9IHBhdGguam9pbihwcm9qZWN0UGF0aCwgXCJzcmNcIiwgXCJtYWluXCIsIFwic2NhbGFcIiwgXCJGb28uc2NhbGFcIilcbiAgICAgICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgICAgICAgIG9iamVjdCBGb28ge1xuICAgICAgICAgICAgICAgIGRlZiBiYXIgPSBcImJhelwiO1xuICAgICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgICB3cml0ZUZpbGUoZm9vRG90U2NhbGEsIGNvbnRlbnQpO1xuICAgICAgICBjbGllbnQucG9zdCh7XCJ0eXBlaGludFwiOlwiQ29ubmVjdGlvbkluZm9SZXFcIn0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiZ290IGFuIGFuc3dlcjogXCIsIHJlcylcbiAgICAgICAgICAgIC8vIGNsaWVudC50eXBlY2hlY2tGaWxlKGZvb0RvdFNjYWxhKTtcbiAgICAgICAgICAgIC8vIGNsaWVudC50eXBlY2hlY2tCdWZmZXIoZm9vRG90U2NhbGEsIGNvbnRlbnQsIChyZXMpID0+IHtcbiAgICAgICAgICAgIC8vICAgICBsb2cuZGVidWcoXCJnb3QgYW4gYW5zd2VyOiBcIiwgcmVzKVxuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7Il19
